#!/usr/bin/env bash

set -o errexit
set -o noclobber
set -o nounset
set -o pipefail

declare SCRIPT_ABSOLUTE
SCRIPT_ABSOLUTE="$(realpath "$BASH_SOURCE")"
declare SCRIPT_BASE_ABSOLUTE
SCRIPT_BASE_ABSOLUTE="$(realpath "${SCRIPT_ABSOLUTE%/*}")"

# function die() {
#     echo -E "$@" >&2
#     exit 1
# }

function checkPrerequisites() {
    (
        pushd "$SCRIPT_BASE_ABSOLUTE" > /dev/null

        # NOTE: while enforcing the Node.js version is more important during package usage, it's not a bad idea to run generation with known working versions.
        node --eval 'require("engine-check")({ searchRoot: __dirname })'

        popd > /dev/null
    )
}

function packageGit() {
    local -r libraryName="$1"
    shift
    local -r libraryVersion="$1"
    shift
    local -r conanRemote="$1"
    shift

    # NOTE: duplicated variables.
    local -r libraryBuildDirectoryPath="${PWD}/build/${libraryName}-v${libraryVersion}"
    local -r libraryPublishDirectoryPath="${PWD}/publish/${libraryName}-v${libraryVersion}"
    local -r buildPackageJson="${libraryBuildDirectoryPath}/package/package.json"
    local -r gitRemote="$(jq --raw-output '"git@github.com:\(.repository | gsub("github:"; "")).git"' "${libraryBuildDirectoryPath}/package/package.json")"
    local -r packageVersion="$(jq --raw-output '"v\(.version)"' "${libraryBuildDirectoryPath}/package/package.json")"

    # TODO: if there are more variables from json files, assemble the string in jq.
    local -r toolingName="$(jq --raw-output '.name' "${SCRIPT_BASE_ABSOLUTE}/package.json")"
    local -r toolingVersion="$(jq --raw-output '.version' "${SCRIPT_BASE_ABSOLUTE}/package.json")"
    local -r toolingGitDescribe="$(git -C "$SCRIPT_BASE_ABSOLUTE" describe --always --tags --dirty --long)"
    local -r toolingGitBranch="$(git -C "$SCRIPT_BASE_ABSOLUTE" branch --show-current)"
    local -r toolingHomepage="$(jq --raw-output '.homepage' "${SCRIPT_BASE_ABSOLUTE}/package.json")"
    read -d '' commitMessage <<EOF || true
Automatially generated package update

- Based on \`${libraryName}\` v${libraryVersion} from \`conan\` remote \`${conanRemote}\`.
- Generated by \`${toolingName}\` v${toolingVersion} (\`${toolingGitDescribe}\` on \`${toolingGitBranch}\`).

See

- ${toolingHomepage}
EOF

    if [[ ! -d "$libraryPublishDirectoryPath" ]];
    then
        mkdir "$libraryPublishDirectoryPath"

        (
            pushd "$libraryPublishDirectoryPath" > /dev/null

            if ! git clone "$gitRemote" ".";
            then
                # NOTE: to avoid hash collisions for the generated initial commit in git.
                sleep 2

                git init
                touch '.gitignore'
                git add '.gitignore'
                git commit -m "Initial commit"
                git flow init -d

                hub create \
                    --description "$(jq --raw-output '.description' "${buildPackageJson}")" \
                    --homepage "$(jq --raw-output '.homepage' "${buildPackageJson}")" \
                    "$(jq --raw-output '.repository | gsub("github:"; "")' "${buildPackageJson}")" \
                || hub browse --url

                git push 'origin' 'master' 'develop'
            fi

            popd > /dev/null
        )
    fi

    (
        pushd "$libraryPublishDirectoryPath" > /dev/null

        git fetch --all
        git clean -fdx ':/'
        git reset --hard 'develop'

        find . -mindepth 1 -not -ipath './.git' -not -ipath './.git/*' -print0 | xargs -0 rm -rf
        rsync --recursive --exclude='node_modules/***' "${libraryBuildDirectoryPath}/package/" "."

        git add "."
        echo "$commitMessage" | git commit --file "-"
        git flow release start "$packageVersion"
        git flow release finish --sign --message "Automatically generated release" "$packageVersion"
        git push 'origin' 'master' 'develop' "$packageVersion"

        popd > /dev/null
    )
}

function main() {
    checkPrerequisites

    # TODO: split to functions.
    # TODO: better argument handling/verification.
    packageGit "$@"
}

main "$@"
